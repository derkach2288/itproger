
# Метод get_letters возвращает массив букв загаданного слова, которое было
# передано программе в консоли в качестве параметра.

def get_letters

    slovo = ARGV[0]   # Берем загаданное слово из командной строки

    if (slovo == nil || slovo == "")      # Если при запуске программы не указали слово для отгадывания, мы не можем родолжать игру
        abort "Вы не ввели слово для игры"
    end

    return slovo.split("")  # .split метод, который разобьет слово на массив из букв

end


# Метод get_user_input занимается лишь тем, что спрашивает у пользователя,
# какую букву он хочет попробовать в качестве следующего хода.

def get_user_input
    letter = ""
    
    while letter == "" do                  # В цикле будем опрашивать юзера, пока он не введет что-нибудь
        letter = STDIN.gets.chomp          # Спрашиваем у пользователя букву в консоли
    end
    
    return letter                          # Возвращаем полученную от пользователя букву
end


# Метод check_result проверяет введенную пользователем букву и кладет её в один
# из двух массивов — с «хорошими» буквами, которые есть в слове, и «плохими»,
# которых в слове нет.
#
# К тому же, нам очень важен результат, которые вернет этот метод. Мы
# договорились, что он возвращает
#
#  0 — если буква есть в слове (или уже была названа) и игра продолжается
# -1 — если введенной буквы нет в слове
#  1 — если всё слово угадано целиком
#

def check_result(user_input, letters, good_letters, bad_letters)
    
    if (good_letters.include?(user_input) || bad_letters.include?(user_input))  # Если введенная буква уже есть в списке «хороших» или «плохих»
                                                                    
        return 0     # вернем 0, так как ничего не изменилось, игра продолжится.
    end


    if letters.include?(user_input) || # Если в слове есть буква запишем её в массив «хороших» букв
        (user_input == 'е' && letters.include?('ё')) ||
        (user_input == 'ё' && letters.include?('е')) ||
        (user_input == 'и' && letters.include?('й')) ||
        (user_input == 'й' && letters.include?('и'))

        good_letters << user_input  # в массив угаданных букв попадают только уникальные буквы в одном экземпляре. 

        if user_input == 'е'
            good_letters << 'ё'
          end
      
          if user_input == 'ё'
            good_letters << 'е'
          end
      
          if user_input == 'и'
            good_letters << 'й'
          end
      
          if user_input == 'й'
            good_letters << 'и'
          end

        if (letters - good_letters).empty?    # .uniq оставляет в массиве только уникальные буквы, а повторения удаляет.
                      # Если длина массива с уникальными буквами загаданного слово = длине массива отгаданных букв - слово угадано
            return 1  # Если слово угадано - возвращаем 1
        else 
            return 0   # Иначе, игра продолжается. Мы отгадали букву, но не слово.
        end
    else 
        bad_letters << user_input  # Если в слове нет введенной буквы мы добавляем её в массив «плохих» букв и
        return -1                  # возвращаем -1, чтобы основная программа поняла, что пользователь ошибся.
    end

end



# Метод get_word_for_print возвращает нам загаданное слово для вывода на экран:
# если буква отгадана, она отображается, иначе вместо неё отображаются подчеркивания.
# Например, если слово было «молоко» и отгадали буквы «о» и «к», то метод должен
# вернуть строку "__ о __ о к о".

def get_word_for_print(letters, good_letters)
    res = ""
    for item in letters do
        if good_letters.include? item 
            res += item + " "
        else res += "__ "
        end
    end

    return res

end



# Метод print_status выводит на экран текущий статус игры:
# 1. выводить загаданное слово (как в поле чудес)
# 2. информацию об ошибках и уже названные буквы
# 3. ошибок > 7 - сообщить о поражении
# 4. слово угадано - сообщить о победе

def print_status(letters, good_letters, bad_letters, errors)
    puts "\nСлово: " + get_word_for_print(letters, good_letters)

    puts "Ошибки (#{errors}): #{bad_letters.join(", ")}"     # .join выводит элементы массива в строчку без квадратных скобок 
                                                         # и между элементами ставит то, что указываем в скобках

    if errors >= 7
        puts "Вы проиграли :("
    else
        if (letters - good_letters).empty?
            puts "Поздравляем! Вы вииграли! \n\n"
        else
            puts "У вас осталось попыток: " + (7 - errors).to_s
        end
    end


end


# Метод cls, очищающий экран, вызывает системную команду. В Mac OS/Linux —
# clear, в Windows — cls. Оператор || тут необходим на случай, если первый вызов
# пройдет неудачно (например, такой команды нет, как, например и, команды 'cls'
# на Linux). Если первый system вернет false будет вызвана другая команда.
def cls
    
    system "clear" or system "cls"
    
end